When you init a git repository, it creates a .git file in the directory you're in, including an empty repository, to which you can commit the files in that directory if you want.  You need to do it as a first step in committing to a repository.

The staging area acts as a filter for what goes from the working directory to the repository during a commit. Maybe this is helpful when you are dealing with a large working directory, a large number of commits, but only a small number of files.  It could thus narrow your scope/focus.  It could also help you avoid making accidental, unwanted changes to some files in the working directory.

You can use the staging area to make sure you have one commit per logical change, by first executing "git diff --staged" and comparing the staging area with the repository, and then commiting only after confirming the results.

Branches help you keep your history organized by allowing you to continue developing in multiple directions simultaneously, without knowing which version (branch) you will eventually end up wanting to keep. 

Diagrams are a huge help in visualizing the branch structure of a project.  Without them, you are at the mercy of a bunch of commit numbers and comments, without clearly understanding how they are related.  A diagram is like a map, and if you don't have one, you can still follow directions, but you can't make your own directions.

Merging two branches takes the last common version of the two, adds the changes made by both branches, and returns a new, common, version. That's why the diagram of the commits shows the common ancestor commit branching off into two separate chains of commits and then reuniting.

Automatic merging with Git is a way to speed up the potentially difficult process of keeping a project unified when there are multiple directions of development being explored simultaneously.  Git takes care of keeping track of which parts of code are new, or newly deleted, and which ones have stayed the same. On the other hand, when there are conflicts between the two merging branches, the process becomes less automatic, and the developer or developers need to resolve the issue, albeit not without Git's help, since Git finds and focuses on the conflicting areas, making the resolution much more manageable.  I guess the potential drawback to automatic merging, vs. manual, is the same as that of any automatic process:  It makes it easier to miss the details of what's happening, so that the developers in a sense lose some level of control if they're not careful.